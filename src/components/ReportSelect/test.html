<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="600" height="300">123</canvas>
    <!-- <script>
      const canvas = document.createElement('canvas')

      if (canvas.getContext) {
        // 1.生成画布
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = 'rgb(200,0,0)'
        // ctx.fillRect(10, 10, 55, 50)
        // ctx.fillStyle = 'rgba(0, 0, 200, 0.5)'
        // ctx.fillRect(30, 30, 55, 50)

        ctx.fillRect(25, 25, 100, 100) //绘制一个填充的矩形
        ctx.clearRect(45, 45, 60, 60) //清除指定矩形区域，让清除部分完全透明
        ctx.strokeRect(50, 50, 50, 50) //绘制一个矩形的边框
        document.body.appendChild(canvas)
      } else {
        console.log('浏览器不兼容')
      }
    </script> -->
    <!-- <script>
      const canvas = document.createElement('canvas')

      if (canvas.getContext) {
        // 1.生成画布
        const ctx = canvas.getContext('2d')
        // ctx.beginPath() //新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径
        // ctx.moveTo(75, 50) //将笔触移动到指定的坐标 x 以及 y 上。
        // ctx.lineTo(100, 75) //绘制直线，需要用到的方法lineTo()。绘制一条从当前位置到指定 x 以及 y 位置的直线。该方法有两个参数：x 以及 y，代表坐标系中直线结束的点。开始点和之前的绘制路径有关，之前路径的结束点就是接下来的开始点，等等。。。开始点也可以通过moveTo()函数改变。
        // ctx.lineTo(100, 25)
        // ctx.lineTo(75, 50)
        // ctx.stroke() //通过线条来绘制图形轮廓。
        // ctx.fill()//通过填充路径的内容区域生成实心的图形

        // ctx.beginPath()
        // ctx.arc(75, 75, 50, 0, Math.PI * 2, true) // 绘制
        //arc(x, y, radius, startAngle, endAngle, anticlockwise)
        // 画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。
        // 这里详细介绍一下 arc 方法，该方法有六个参数：x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以 x 轴为基准。参数anticlockwise为一个布尔值。为 true 时，是逆时针方向，否则顺时针方向。
        // ctx.moveTo(110, 75)
        // ctx.arc(75, 75, 35, 0, Math.PI, false) // 口 (顺时针)
        // ctx.moveTo(65, 65)
        // ctx.arc(60, 65, 5, 0, Math.PI * 2, true) // 左眼
        // ctx.moveTo(95, 65)
        // ctx.arc(90, 65, 5, 0, Math.PI * 2, true) // 右眼
        // ctx.stroke()

        // 填充三角形
        ctx.beginPath()
        ctx.moveTo(25, 25)
        ctx.lineTo(105, 25)
        ctx.lineTo(25, 105)
        ctx.fill()

        // 描边三角形
        ctx.beginPath()
        ctx.moveTo(125, 125)
        ctx.lineTo(125, 45)
        ctx.lineTo(45, 125)
        ctx.closePath()
        ctx.stroke()
        document.body.appendChild(canvas)
      } else {
        console.log('浏览器不兼容')
      }
    </script> -->
    <!-- <script>
      function draw() {
        var canvas = document.getElementById('canvas')
        if (canvas.getContext) {
          var ctx = canvas.getContext('2d')

          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 3; j++) {
              ctx.beginPath()
              var x = 25 + j * 50 // x 坐标值
              var y = 25 + i * 50 // y 坐标值
              var radius = 20 // 圆弧半径
              var startAngle = 0 // 开始点
              var endAngle = Math.PI + (Math.PI * j) / 2 // 结束点
              var anticlockwise = i % 2 == 0 ? false : true // 顺时针或逆时针

              ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)

              if (i > 1) {
                ctx.fill()
              } else {
                ctx.stroke()
              }
            }
          }
        }
      }
      draw()
    </script> -->
    <!-- <script>
      function draw() {
        var canvas = document.getElementById('canvas')
        if (canvas.getContext) {
          var ctx = canvas.getContext('2d')

          roundedRect(ctx, 12, 12, 150, 150, 15)
          roundedRect(ctx, 19, 19, 150, 150, 9)
          roundedRect(ctx, 53, 53, 49, 33, 10)
          roundedRect(ctx, 53, 119, 49, 16, 6)
          roundedRect(ctx, 135, 53, 49, 33, 10)
          roundedRect(ctx, 135, 119, 25, 49, 10)

          ctx.beginPath()
          ctx.arc(37, 37, 13, Math.PI / 7, -Math.PI / 7, false)
          ctx.lineTo(31, 37)
          ctx.fill()

          for (var i = 0; i < 8; i++) {
            ctx.fillRect(51 + i * 16, 35, 4, 4)
          }

          for (i = 0; i < 6; i++) {
            ctx.fillRect(115, 51 + i * 16, 4, 4)
          }

          for (i = 0; i < 8; i++) {
            ctx.fillRect(51 + i * 16, 99, 4, 4)
          }

          ctx.beginPath()
          ctx.moveTo(83, 116)
          ctx.lineTo(83, 102)
          ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)
          ctx.bezierCurveTo(105, 88, 111, 94, 111, 102)
          ctx.lineTo(111, 116)
          ctx.lineTo(106.333, 111.333)
          ctx.lineTo(101.666, 116)
          ctx.lineTo(97, 111.333)
          ctx.lineTo(92.333, 116)
          ctx.lineTo(87.666, 111.333)
          ctx.lineTo(83, 116)
          ctx.fill()

          ctx.fillStyle = 'white'
          ctx.beginPath()
          ctx.moveTo(91, 96)
          ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)
          ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)
          ctx.bezierCurveTo(94, 106, 95, 103, 95, 101)
          ctx.bezierCurveTo(95, 99, 94, 96, 91, 96)
          ctx.moveTo(103, 96)
          ctx.bezierCurveTo(100, 96, 99, 99, 99, 101)
          ctx.bezierCurveTo(99, 103, 100, 106, 103, 106)
          ctx.bezierCurveTo(106, 106, 107, 103, 107, 101)
          ctx.bezierCurveTo(107, 99, 106, 96, 103, 96)
          ctx.fill()

          ctx.fillStyle = 'black'
          ctx.beginPath()
          ctx.arc(101, 102, 2, 0, Math.PI * 2, true)
          ctx.fill()

          ctx.beginPath()
          ctx.arc(89, 102, 2, 0, Math.PI * 2, true)
          ctx.fill()
        }
      }

      // 封装的一个用于绘制圆角矩形的函数。

      function roundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath()
        ctx.moveTo(x, y + radius)
        ctx.lineTo(x, y + height - radius)
        ctx.quadraticCurveTo(x, y + height, x + radius, y + height)
        ctx.lineTo(x + width - radius, y + height)
        ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius)
        ctx.lineTo(x + width, y + radius)
        ctx.quadraticCurveTo(x + width, y, x + width - radius, y)
        ctx.lineTo(x + radius, y)
        ctx.quadraticCurveTo(x, y, x, y + radius)
        ctx.stroke()
      }
      draw()
    </script> -->
    <!-- <script>
      function draw() {
        const canvas = document.getElementById('canvas')
        var ctx = canvas.getContext('2d')
        for (var i = 0; i < 6; i++) {
          for (var j = 0; j < 6; j++) {
            ctx.fillStyle =
              'rgb(' + Math.floor(255 - 42.5 * i) + ',' + Math.floor(255 - 42.5 * j) + ',0)'
            ctx.fillRect(j * 25, i * 25, 25, 25)
            ctx.globalAlpha = 0.2
          }
        }
      }
      draw()
    </script> -->

    <!-- <script>
      function compressImg(file, quality) {
        return new Promise(resolve => {
          // 创建 FileReader
          const reader = new FileReader()
          reader.onload = ({ target: { result: src } }) => {
            // 创建 img 元素
            const image = new Image()
            image.onload = async () => {
              // 创建 canvas 元素
              const canvas = document.createElement('canvas')
              canvas.width = image.width
              canvas.height = image.height
              // 绘制 canvas
              canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height)
              const canvasURL = canvas.toDataURL('image/webp', quality)
              // 将base64编码转为字符串
              const buffer = atob(canvasURL.split(',')[1])
              let length = buffer.length
              const bufferArray = new Uint8Array(length)
              while (length--) {
                bufferArray[length] = buffer.charCodeAt(length)
              }
              const [fileName, fileType] = file.name.split('.')
              const miniFile = new File([bufferArray], `${fileName}-compressed.${fileType}`, {
                type: 'image/png',
              })
              resolve({
                file: miniFile,
                origin: file,
                beforeSrc: src,
                afterSrc: canvasURL,
                beforeKB: Number((file.size / 1024).toFixed(2)),
                afterKB: Number((miniFile.size / 1024).toFixed(2)),
              })
            }
            image.src = src
          }
          reader.readAsDataURL(file)
        })
      }
    </script> -->
    <script>
      // function draw() {
      //   var ctx = document.getElementById('canvas').getContext('2d')
      //   var img = new Image()
      //   img.onload = function () {
      //     ctx.drawImage(img, 0, 0)
      //     ctx.beginPath()
      //     ctx.moveTo(30, 96)
      //     ctx.lineTo(70, 66)
      //     ctx.lineTo(103, 76)
      //     ctx.lineTo(170, 15)
      //     ctx.stroke()
      //   }
      //   img.src =
      //     'https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images/canvas_backdrop.png'
      // }
      function draw() {
        var ctx = document.getElementById('canvas').getContext('2d')
        ctx.fillRect(0, 0, 150, 150)
        ctx.translate(75, 75)

        // Create a circular clipping path
        ctx.beginPath()
        ctx.arc(0, 0, 60, 0, Math.PI * 2, true)
        ctx.clip()

        // draw background
        // var lingrad = ctx.createLinearGradient(0, -75, 0, 75)
        // lingrad.addColorStop(0, '#232256')
        // lingrad.addColorStop(1, '#143778')

        // ctx.fillStyle = lingrad
        // ctx.fillRect(-75, -75, 150, 150)

          // draw stars
        // for (var j = 1; j < 50; j++) {
        //   ctx.save()
        //   ctx.fillStyle = '#fff'
        //   ctx.translate(75 - Math.floor(Math.random() * 150), 75 - Math.floor(Math.random() * 150))
        //   drawStar(ctx, Math.floor(Math.random() * 4) + 2)
        //   ctx.restore()
        // }

        // function drawStar(ctx, r) {
        //   ctx.save()
        //   ctx.beginPath()
        //   ctx.moveTo(r, 0)
        //   for (var i = 0; i < 9; i++) {
        //     ctx.rotate(Math.PI / 5)
        //     if (i % 2 == 0) {
        //       ctx.lineTo((r / 0.525731) * 0.200811, 0)
        //     } else {
        //       ctx.lineTo(r, 0)
        //     }
        //   }

        //   ctx.closePath()
        //   ctx.fill()
        //   ctx.restore()
        // }
      }
      // function draw() {
      //   var ctx = document.getElementById('canvas').getContext('2d')

      //   ctx.fillRect(0, 0, 150, 150) // 使用默认设置绘制一个矩形
      //   ctx.save() // 保存默认状态

      //   ctx.fillStyle = '#09F' // 在原有配置基础上对颜色做改变
      //   ctx.fillRect(15, 15, 120, 120) // 使用新的设置绘制一个矩形

      //   ctx.save() // 保存当前状态
      //   ctx.fillStyle = '#FFF' // 再次改变颜色配置
      //   ctx.globalAlpha = 0.5
      //   ctx.fillRect(30, 30, 90, 90) // 使用新的配置绘制一个矩形

      //   ctx.restore() // 重新加载之前的颜色状态
      //   ctx.fillRect(45, 45, 60, 60) // 使用上一次的配置绘制一个矩形

      //   ctx.restore() // 加载默认颜色配置
      //   ctx.fillRect(60, 60, 30, 30) // 使用加载的配置绘制一个矩形
      // }

      draw()
    </script>
  </body>
</html>
